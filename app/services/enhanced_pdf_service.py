"""
Enhanced PDF Export Service for Legal Documents
Provides professional PDF generation with proper legal document formatting.
"""

import asyncio
import logging
from typing import Dict, Any, Optional, Tuple
from datetime import datetime
import uuid
import base64
import io
import os
from pathlib import Path

# For production PDF generation
try:
    from weasyprint import HTML, CSS
    from weasyprint.text.fonts import FontConfiguration
    WEASYPRINT_AVAILABLE = True
except ImportError:
    WEASYPRINT_AVAILABLE = False
    logging.warning("WeasyPrint not available. PDF generation will use fallback method.")

logger = logging.getLogger(__name__)

class EnhancedPDFService:
    """Enhanced PDF export service with professional legal document formatting"""
    
    def __init__(self):
        self.export_history = {}
        self.temp_dir = Path("temp_exports")
        self.temp_dir.mkdir(exist_ok=True)
        
        # Initialize font configuration for better PDF rendering
        if WEASYPRINT_AVAILABLE:
            self.font_config = FontConfiguration()
        
    async def export_document_to_pdf(
        self,
        content: str,
        metadata: Dict[str, Any],
        export_options: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """Export HTML document content to professional PDF"""
        
        try:
            export_id = f"export_{uuid.uuid4().hex[:8]}"
            export_options = export_options or {}
            
            # Generate filename
            template_name = metadata.get('template_name', 'document')
            safe_name = self._sanitize_filename(template_name)
            filename = f"{safe_name}_{export_id}.pdf"
            
            # Enhance HTML content for PDF
            enhanced_html = self._enhance_html_for_pdf(content, metadata, export_options)
            
            # Generate PDF
            if WEASYPRINT_AVAILABLE:
                pdf_data = await self._generate_pdf_with_weasyprint(enhanced_html, export_options)
            else:
                pdf_data = await self._generate_pdf_fallback(enhanced_html, metadata)
            
            # Save PDF file
            file_path = self.temp_dir / filename
            with open(file_path, 'wb') as f:
                f.write(pdf_data)
            
            # Create export record
            export_record = {
                "export_id": export_id,
                "filename": filename,
                "file_path": str(file_path),
                "content_type": "application/pdf",
                "file_size": len(pdf_data),
                "exported_at": datetime.utcnow().isoformat() + "Z",
                "status": "completed",
                "metadata": metadata,
                "export_options": export_options
            }
            
            self.export_history[export_id] = export_record
            
            logger.info(f"PDF export completed: {export_id}")
            
            return {
                "export_id": export_id,
                "filename": filename,
                "status": "completed",
                "file_size": len(pdf_data),
                "download_url": f"/api/v1/generate/export/{export_id}/download",
                "expires_at": self._calculate_expiry_time(),
                "content_type": "application/pdf",
                "exported_at": export_record["exported_at"]
            }
            
        except Exception as e:
            logger.error(f"PDF export failed: {e}")
            raise
    
    def _enhance_html_for_pdf(
        self, 
        html_content: str, 
        metadata: Dict[str, Any], 
        export_options: Dict[str, Any]
    ) -> str:
        """Enhance HTML content specifically for PDF generation"""
        
        # Add PDF-specific CSS
        pdf_css = """
        <style>
            @page {
                size: A4;
                margin: 2.5cm 2cm;
                @top-left {
                    content: "CONFIDENTIAL LEGAL DOCUMENT";
                    font-size: 8pt;
                    color: #666;
                }
                @top-right {
                    content: "Page " counter(page) " of " counter(pages);
                    font-size: 8pt;
                    color: #666;
                }
                @bottom-center {
                    content: "Generated by Counsel AI - """ + metadata.get('generated_at', '') + """";
                    font-size: 8pt;
                    color: #666;
                }
            }
            
            body {
                font-family: 'Times New Roman', serif;
                font-size: 11pt;
                line-height: 1.5;
                color: #000;
            }
            
            .page-break {
                page-break-before: always;
            }
            
            .no-break {
                page-break-inside: avoid;
            }
            
            .signature-section {
                page-break-inside: avoid;
                margin-top: 40px;
            }
            
            .compliance-footer {
                page-break-inside: avoid;
                margin-top: 30px;
            }
            
            h1, h2, h3 {
                page-break-after: avoid;
            }
            
            .clause {
                orphans: 2;
                widows: 2;
            }
        </style>
        """
        
        # Insert PDF CSS into HTML head
        if '<head>' in html_content:
            html_content = html_content.replace('<head>', f'<head>{pdf_css}')
        else:
            html_content = f'<html><head>{pdf_css}</head><body>{html_content}</body></html>'
        
        # Add compliance watermark if requested
        if export_options.get('add_watermark', True):
            watermark = self._create_compliance_watermark(metadata)
            html_content = html_content.replace('<body>', f'<body>{watermark}')
        
        return html_content
    
    def _create_compliance_watermark(self, metadata: Dict[str, Any]) -> str:
        """Create a compliance watermark for the document"""
        compliance_score = metadata.get('compliance_score', 0.95)
        
        watermark = f"""
        <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-45deg); 
                    font-size: 72pt; color: rgba(0,0,0,0.05); z-index: -1; pointer-events: none;">
            COUNSEL AI<br>
            {int(compliance_score * 100)}% COMPLIANT
        </div>
        """
        return watermark
    
    async def _generate_pdf_with_weasyprint(
        self, 
        html_content: str, 
        export_options: Dict[str, Any]
    ) -> bytes:
        """Generate PDF using WeasyPrint for high-quality output"""
        
        try:
            # Create HTML object
            html_doc = HTML(string=html_content)
            
            # Generate PDF
            pdf_bytes = html_doc.write_pdf(
                font_config=self.font_config,
                optimize_images=True
            )
            
            return pdf_bytes
            
        except Exception as e:
            logger.error(f"WeasyPrint PDF generation failed: {e}")
            raise
    
    async def _generate_pdf_fallback(
        self, 
        html_content: str, 
        metadata: Dict[str, Any]
    ) -> bytes:
        """Fallback PDF generation method"""
        
        # Simple fallback - create a basic PDF-like content
        # In production, you might use other libraries like reportlab
        
        fallback_content = f"""
PDF DOCUMENT (Fallback Generation)
================================

{metadata.get('template_name', 'Legal Document')}
Generated: {metadata.get('generated_at', datetime.utcnow().isoformat())}

{html_content}

---
Generated by Counsel AI Legal Document System
This is a fallback PDF generation. For production use, install WeasyPrint.
"""
        
        # Return as bytes (this is a simplified fallback)
        return fallback_content.encode('utf-8')
    
    def _sanitize_filename(self, filename: str) -> str:
        """Sanitize filename for safe file system usage"""
        import re
        # Remove or replace invalid characters
        sanitized = re.sub(r'[<>:"/\\|?*]', '_', filename)
        sanitized = re.sub(r'\s+', '_', sanitized)
        return sanitized[:50]  # Limit length
    
    def _calculate_expiry_time(self) -> str:
        """Calculate expiry time for download links"""
        from datetime import timedelta
        expiry = datetime.utcnow() + timedelta(hours=24)
        return expiry.isoformat() + "Z"
    
    def get_export_record(self, export_id: str) -> Optional[Dict[str, Any]]:
        """Get export record by ID"""
        return self.export_history.get(export_id)
    
    def get_pdf_file_path(self, export_id: str) -> Optional[str]:
        """Get file path for an exported PDF"""
        record = self.export_history.get(export_id)
        if record and record['status'] == 'completed':
            return record['file_path']
        return None
    
    async def cleanup_expired_exports(self):
        """Clean up expired export files"""
        try:
            current_time = datetime.utcnow()
            expired_exports = []
            
            for export_id, record in self.export_history.items():
                exported_at = datetime.fromisoformat(record['exported_at'].replace('Z', ''))
                if (current_time - exported_at).total_seconds() > 86400:  # 24 hours
                    expired_exports.append(export_id)
            
            for export_id in expired_exports:
                record = self.export_history[export_id]
                file_path = Path(record['file_path'])
                if file_path.exists():
                    file_path.unlink()
                del self.export_history[export_id]
                logger.info(f"Cleaned up expired export: {export_id}")
                
        except Exception as e:
            logger.error(f"Error cleaning up exports: {e}")

# Global instance
enhanced_pdf_service = EnhancedPDFService()
